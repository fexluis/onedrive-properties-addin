<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <title>Complemento de Excel con Office.js</title>
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 10px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        ul { list-style-type: none; padding-left: 0; }
        #status img { max-width: 100px; display: block; margin: 10px auto; }
    </style>
</head>
<body>
    <h2>Complemento de Prueba</h2>
    <button id="runButton">Escribir en A1</button>
    <button id="getFolderIdButton">Listar Archivos en Excel</button>
    <div id="status">Cargando Office.js...</div>

    <script type="text/javascript">
        const clientId = "c1b4b92a-ddd4-471e-a375-4fbe017f1d31";
        const redirectUri = "https://fexluis.github.io/onedrive-properties-addin/popup.html";
        const scope = "Files.Read.All Sites.Read.All User.Read profile openid";
        const excelExtensions = ['xls', 'xlsx', 'xlsm', 'xlsb'];
        const waitingGif = 'https://media.giphy.com/media/3oEjI6SIIHBdRxXI40/giphy.gif';
        const recordsPerSheet = 10;
        let authWindow = null;

        const officeReady = new Promise((resolve, reject) => {
            Office.onReady(info => {
                if (info.host && info.platform) {
                    console.log(`Office.js cargado. Host: ${info.host}, Plataforma: ${info.platform}`);
                    document.getElementById("status").innerHTML = "Complemento listo.";
                    resolve();
                } else {
                    const errorMsg = "Error: Office.js no se inicializó correctamente.";
                    console.error(errorMsg, info);
                    document.getElementById("status").innerHTML = errorMsg;
                    reject(new Error(errorMsg));
                }
            }).catch(error => {
                const errorMsg = `Error al cargar Office.js: ${error.message}`;
                console.error(errorMsg, error);
                document.getElementById("status").innerHTML = errorMsg;
                reject(error);
            });
        });

        officeReady.then(() => {
            const runButton = document.getElementById("runButton");
            const getFolderIdButton = document.getElementById("getFolderIdButton");
            runButton.disabled = false;
            getFolderIdButton.disabled = false;
            runButton.onclick = run;
            getFolderIdButton.onclick = listFilesInParentFolder;
        });

        async function run() { /* ... (sin cambios) */ }

        async function getPDFPageCount(url, accessToken) { /* ... (sin cambios) */ }

        async function getPDFText(url, accessToken) { /* ... (sin cambios) */ }

        async function fetchWithAuth(url, accessToken, errorMessage) {
            console.log(`Solicitando ${url}`);
            const response = await fetch(url, { headers: { "Authorization": `Bearer ${accessToken}` } });
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`Error en ${url}: ${response.status} - ${errorText}`);
                if (response.status === 401) {
                    console.log("Token no válido. Solicitando nuevo token...");
                    localStorage.removeItem("accessToken");
                    await initiateOAuthFlow();
                    throw new Error("Reautenticación requerida");
                }
                throw new Error(`${errorMessage}: ${response.status} - ${errorText}`);
            }
            const data = await response.json();
            if (!data) throw new Error(`${errorMessage}: Respuesta vacía`);
            console.log(`Respuesta recibida de ${url}:`, data);
            return data;
        }

        function formatDate(date) { /* ... (sin cambios) */ }

        function showWaitingGif(message) { /* ... (sin cambios) */ }

        async function applyFormatToRange(range) { /* ... (sin cambios) */ }

        async function writeDataToSheet(context, sheet, data, startRow, files, fileStartIndex) { /* ... (sin cambios) */ }

        function separateCamelCase(text) {
            return text.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/([A-Z])([A-Z][a-z])/g, '$1 $2');
        }

        async function listFilesInParentFolder() {
            let statusMessage = "";
            try {
                await officeReady;
                console.log("Iniciando listFilesInParentFolder");
                let accessToken = localStorage.getItem("accessToken");
                if (!accessToken) {
                    await initiateOAuthFlow();
                    return;
                }

                showWaitingGif("Obteniendo nombre del archivo...");
                let fileName = "";
                await Excel.run(async context => {
                    const workbook = context.workbook;
                    workbook.load("name");
                    await context.sync();
                    fileName = workbook.name;
                    statusMessage = `Nombre del archivo: ${fileName}`;
                    document.getElementById("status").innerHTML = statusMessage;
                });

                showWaitingGif("Obteniendo drive raíz...");
                const rootData = await fetchWithAuth("https://graph.microsoft.com/v1.0/me/drive/root", accessToken, "Error al obtener la raíz");
                if (!rootData || !rootData.parentReference) {
                    throw new Error("Respuesta de raíz inválida: parentReference no disponible");
                }
                const driveId = rootData.parentReference.driveId;
                statusMessage += `<br>Drive ID de la raíz: ${driveId}`;
                document.getElementById("status").innerHTML = statusMessage;

                showWaitingGif("Buscando archivo reciente...");
                const recentData = await fetchWithAuth("https://graph.microsoft.com/v1.0/me/drive/recent", accessToken, "Error al obtener archivos recientes");
                if (!recentData || !recentData.value) {
                    throw new Error("Respuesta de recientes inválida: value no disponible");
                }
                const file = recentData.value.find(item => item.name === fileName && item.file);
                if (!file) {
                    statusMessage += "<br>Archivo no encontrado en recientes.";
                    document.getElementById("status").innerHTML = statusMessage;
                    return;
                }
                if (!file.parentReference) {
                    throw new Error(`Archivo ${fileName} no tiene parentReference`);
                }
                const parentFolderId = file.parentReference.id;
                const fileDriveId = file.parentReference.driveId;
                statusMessage = `ID de la carpeta padre: ${parentFolderId}`;
                document.getElementById("status").innerHTML = statusMessage;

                showWaitingGif("Listando archivos en la carpeta padre...");
                const childrenData = await fetchWithAuth(`https://graph.microsoft.com/v1.0/drives/${fileDriveId}/items/${parentFolderId}/children`, accessToken, "Error al listar archivos");

                const files = childrenData.value.filter(item => {
                    const ext = item.name.includes('.') && !item.folder ? item.name.split('.').pop().toLowerCase() : "";
                    return !excelExtensions.includes(ext);
                });
                const tableData = [];

                showWaitingGif(`Procesando ${files.length} archivos...`);
                const filePromises = files.map(async (item, index) => {
                    const createDate = new Date(item.createdDateTime || new Date());
                    const modifiedDate = new Date(item.lastModifiedDateTime || item.createdDateTime || new Date());
                    const formattedCreateDate = formatDate(createDate);
                    const formattedModifiedDate = formatDate(modifiedDate);
                    const sizeInKB = (item.size || 0) / 1024;
                    const extension = item.name.includes('.') && !item.folder ? item.name.split('.').pop().toUpperCase() : "";
                    const nameWithoutExtension = item.name.includes('.') ? item.name.substring(0, item.name.lastIndexOf('.')) : item.name;

                    let pageCount = 1;
                    let newFileName = item.name || "Sin nombre";
                    if (extension === "PDF" && !item.folder) {
                        const contentUrl = `https://graph.microsoft.com/v1.0/drives/${fileDriveId}/items/${item.id}/content`;
                        pageCount = await getPDFPageCount(contentUrl, accessToken);
                        const foundText = await getPDFText(contentUrl, accessToken);
                        if (foundText !== "Error") {
                            newFileName = `${nameWithoutExtension}_${foundText}`;
                        }
                        document.getElementById("status").innerHTML = `Procesando archivo ${index + 1}/${files.length}<br><img src="${waitingGif}" alt="Esperando...">`;
                    }

                    const fileNameParts = nameWithoutExtension.split("_");
                    const columnCValue = fileNameParts.length > 1 ? separateCamelCase(fileNameParts[1]) : separateCamelCase(nameWithoutExtension);

                    return [
                        newFileName,
                        columnCValue,
                        "N/A",
                        formattedCreateDate,
                        formattedModifiedDate,
                        1,
                        pageCount,
                        extension,
                        `${sizeInKB.toFixed(2)} KB`,
                        item.name || "Sin nombre"
                    ];
                });

                const resolvedTableData = await Promise.all(filePromises);
                tableData.push(...resolvedTableData);

                showWaitingGif("Escribiendo datos en Excel...");
                console.log("Datos a escribir en Excel:", tableData);

                await Excel.run(async context => {
                    let sheet = context.workbook.worksheets.getActiveWorksheet();
                    sheet.load("name");
                    await context.sync();
                    const baseSheetName = sheet.name.split(" ")[0] || "Sheet";

                    const initialRange = sheet.getRange("B10:K29");
                    initialRange.clear("All");

                    for (let i = 0; i < tableData.length; i += recordsPerSheet) {
                        const chunk = tableData.slice(i, i + recordsPerSheet);
                        const fileChunk = files.slice(i, i + recordsPerSheet);
                        const sheetIndex = Math.floor(i / recordsPerSheet);

                        if (i > 0) {
                            const newSheet = sheet.copy("After", sheet);
                            sheet = newSheet;
                            sheet.name = `${baseSheetName} ${sheetIndex + 1}`;
                            console.log(`Hoja copiada: ${sheet.name}`);
                            const clearRange = sheet.getRange("B10:K29");
                            clearRange.clear("All");
                            console.log(`Contenido y formato limpiados en ${sheet.name} B10:K29`);
                        }

                        const formatRange = sheet.getRange("B10:K29");
                        await applyFormatToRange(formatRange);

                        await writeDataToSheet(context, sheet, chunk, 10, files, i);
                        console.log(`Datos escritos en ${sheet.name} desde B10 para registros ${i + 1} a ${i + chunk.length}`);
                        document.getElementById("status").innerHTML = `Escribiendo en ${sheet.name}...`;
                    }

                    await context.sync();
                    console.log("Datos escritos y formato aplicado en todas las hojas");
                    document.getElementById("status").innerHTML = `${statusMessage}<br>Datos escritos en ${Math.ceil(tableData.length / recordsPerSheet)} hoja(s).`;
                });
            } catch (error) {
                document.getElementById("status").innerHTML = `Error: ${error.message}`;
                console.error("Error en listFilesInParentFolder:", error);
            }
        }

        function initiateOAuthFlow() { /* ... (sin cambios) */ }

        // Service Worker integrado
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                const swCode = `
                    const CACHE_NAME = 'onedrive-properties-v1.0.6.3';
                    const urlsToCache = [
                        '/onedrive-properties-addin/',
                        '/onedrive-properties-addin/index.html',
                        'https://appsforoffice.microsoft.com/lib/1/hosted/office.js',
                        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js'
                    ];

                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => {
                                    console.log('Service Worker: Instalando y cacheando recursos');
                                    return cache.addAll(urlsToCache);
                                })
                                .then(() => self.skipWaiting())
                        );
                    });

                    self.addEventListener('activate', event => {
                        event.waitUntil(
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames
                                        .filter(name => name !== CACHE_NAME)
                                        .map(name => caches.delete(name))
                                );
                            }).then(() => self.clients.claim())
                        );
                    });

                    self.addEventListener('fetch', event => {
                        const requestUrl = new URL(event.request.url);
                        if (event.request.method !== 'GET' || 
                            (!requestUrl.href.startsWith('https://fexluis.github.io/') && 
                             !urlsToCache.includes(requestUrl.href))) {
                            event.respondWith(fetch(event.request));
                            return;
                        }

                        event.respondWith(
                            caches.match(event.request)
                                .then(cachedResponse => {
                                    const networkFetch = fetch(event.request)
                                        .then(response => {
                                            if (response.ok) {
                                                return caches.open(CACHE_NAME).then(cache => {
                                                    cache.put(event.request, response.clone());
                                                    return response;
                                                });
                                            }
                                            return response;
                                        })
                                        .catch(() => cachedResponse);
                                    return cachedResponse || networkFetch;
                                })
                        );
                    });

                    self.addEventListener('message', event => {
                        if (event.data === 'skipWaiting') {
                            self.skipWaiting();
                        }
                    });
                `;

                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                navigator.serviceWorker.register(swUrl)
                    .then(registration => {
                        console.log('Service Worker registrado con éxito:', registration);
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    newWorker.postMessage('skipWaiting');
                                    window.location.reload();
                                }
                            });
                        });
                    })
                    .catch(error => console.error('Error al registrar Service Worker:', error));
            });
        }
    </script>
</body>
</html>